{"ast":null,"code":"var _jsxFileName = \"/home/erteduarda/unb/PA/dijkstra-app/src/App.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from 'react';\nimport Map from './components/Map';\nimport styled from 'styled-components';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Container = styled.div`\n  text-align: center;\n  padding: 20px;\n`;\n_c = Container;\nconst Button = styled.button`\n  margin: 10px;\n  padding: 10px 20px;\n  font-size: 16px;\n  cursor: pointer;\n`;\n_c2 = Button;\nfunction App() {\n  _s();\n  const [graph, setGraph] = useState(null);\n  const [path, setPath] = useState([]);\n  const [carPosition, setCarPosition] = useState(null);\n  const generateMap = () => {\n    // Número de nós\n    const numNodes = 6;\n\n    // Gerar nós com posições aleatórias\n    const nodes = Array.from({\n      length: numNodes\n    }, (_, i) => ({\n      id: i,\n      x: Math.random() * 400,\n      y: Math.random() * 400\n    }));\n\n    // Gerar conexões aleatórias entre os nós\n    const edges = [];\n    const maxEdges = numNodes * 2; // Máximo de arestas permitidas\n\n    for (let i = 0; i < maxEdges; i++) {\n      const from = Math.floor(Math.random() * numNodes);\n      const to = Math.floor(Math.random() * numNodes);\n\n      // Garantir que não conectamos o nó a ele mesmo e evitar arestas duplicadas\n      if (from !== to && !edges.find(e => e.from === from && e.to === to || e.from === to && e.to === from)) {\n        edges.push({\n          from,\n          to,\n          weight: Math.floor(Math.random() * 10 + 1) // Peso aleatório entre 1 e 10\n        });\n      }\n    }\n\n    // Garantir que o grafo seja conexo (todo nó acessível)\n    for (let i = 0; i < numNodes - 1; i++) {\n      if (!edges.find(e => e.from === i || e.to === i)) {\n        edges.push({\n          from: i,\n          to: i + 1,\n          weight: Math.floor(Math.random() * 10 + 1)\n        });\n      }\n    }\n    setGraph({\n      nodes,\n      edges\n    });\n    setCarPosition(null); // Resetar a posição do carrinho\n    setPath([]); // Resetar o caminho\n  };\n  const dijkstra = (nodes, edges, startNode, endNode) => {\n    const distances = {};\n    const previous = {};\n    const visited = new Set();\n    nodes.forEach(node => {\n      distances[node.id] = Infinity;\n      previous[node.id] = null;\n    });\n    distances[startNode] = 0;\n    while (visited.size < nodes.length) {\n      const unvisitedNodes = nodes.filter(node => !visited.has(node.id));\n      const currentNode = unvisitedNodes.reduce((a, b) => distances[a.id] < distances[b.id] ? a : b, unvisitedNodes[0]);\n      if (distances[currentNode.id] === Infinity) break;\n      visited.add(currentNode.id);\n      edges.forEach(edge => {\n        if (edge.from === currentNode.id || edge.to === currentNode.id) {\n          const neighborId = edge.from === currentNode.id ? edge.to : edge.from;\n          if (!visited.has(neighborId)) {\n            const newDist = distances[currentNode.id] + edge.weight;\n            if (newDist < distances[neighborId]) {\n              distances[neighborId] = newDist;\n              previous[neighborId] = currentNode.id;\n            }\n          }\n        }\n      });\n    }\n    const path = [];\n    let current = endNode;\n    while (current !== null) {\n      path.unshift(current);\n      current = previous[current];\n    }\n    return {\n      path,\n      distances\n    };\n  };\n  const startSimulation = () => {\n    if (!graph) return;\n    const {\n      nodes,\n      edges\n    } = graph;\n\n    // Calcular o menor caminho usando o algoritmo de Dijkstra\n    const result = dijkstra(nodes, edges, 0, nodes.length - 1); // Do nó 0 ao último nó\n    setPath(result.path);\n\n    // Animar o carrinho ao longo do caminho\n    let step = 0;\n    const interval = setInterval(() => {\n      if (step < result.path.length) {\n        const currentNode = nodes.find(node => node.id === result.path[step]);\n        setCarPosition({\n          x: currentNode.x,\n          y: currentNode.y\n        });\n        step++;\n      } else {\n        clearInterval(interval); // Parar a animação ao final do caminho\n      }\n    }, 1000); // Mover o carrinho a cada 1 segundo\n  };\n  return /*#__PURE__*/_jsxDEV(Container, {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Algoritmo de Dijkstra\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 138,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Button, {\n      onClick: generateMap,\n      children: \"Gerar Mapa\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 139,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Button, {\n      onClick: startSimulation,\n      children: \"Iniciar\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 140,\n      columnNumber: 7\n    }, this), graph && /*#__PURE__*/_jsxDEV(Map, {\n      graph: graph,\n      carPosition: carPosition\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 141,\n      columnNumber: 17\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 137,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"4dTV+wm6M6geUw9H4TlsYBNgyYA=\");\n_c3 = App;\nexport default App;\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"Container\");\n$RefreshReg$(_c2, \"Button\");\n$RefreshReg$(_c3, \"App\");","map":{"version":3,"names":["React","useState","Map","styled","jsxDEV","_jsxDEV","Container","div","_c","Button","button","_c2","App","_s","graph","setGraph","path","setPath","carPosition","setCarPosition","generateMap","numNodes","nodes","Array","from","length","_","i","id","x","Math","random","y","edges","maxEdges","floor","to","find","e","push","weight","dijkstra","startNode","endNode","distances","previous","visited","Set","forEach","node","Infinity","size","unvisitedNodes","filter","has","currentNode","reduce","a","b","add","edge","neighborId","newDist","current","unshift","startSimulation","result","step","interval","setInterval","clearInterval","children","fileName","_jsxFileName","lineNumber","columnNumber","onClick","_c3","$RefreshReg$"],"sources":["/home/erteduarda/unb/PA/dijkstra-app/src/App.js"],"sourcesContent":["import React, { useState } from 'react';\nimport Map from './components/Map';\nimport styled from 'styled-components';\n\nconst Container = styled.div`\n  text-align: center;\n  padding: 20px;\n`;\n\nconst Button = styled.button`\n  margin: 10px;\n  padding: 10px 20px;\n  font-size: 16px;\n  cursor: pointer;\n`;\n\nfunction App() {\n  const [graph, setGraph] = useState(null);\n  const [path, setPath] = useState([]);\n  const [carPosition, setCarPosition] = useState(null);\n\n  const generateMap = () => {\n    // Número de nós\n    const numNodes = 6;\n\n    // Gerar nós com posições aleatórias\n    const nodes = Array.from({ length: numNodes }, (_, i) => ({\n      id: i,\n      x: Math.random() * 400,\n      y: Math.random() * 400,\n    }));\n\n    // Gerar conexões aleatórias entre os nós\n    const edges = [];\n    const maxEdges = numNodes * 2; // Máximo de arestas permitidas\n\n    for (let i = 0; i < maxEdges; i++) {\n      const from = Math.floor(Math.random() * numNodes);\n      const to = Math.floor(Math.random() * numNodes);\n\n      // Garantir que não conectamos o nó a ele mesmo e evitar arestas duplicadas\n      if (from !== to && !edges.find((e) => (e.from === from && e.to === to) || (e.from === to && e.to === from))) {\n        edges.push({\n          from,\n          to,\n          weight: Math.floor(Math.random() * 10 + 1), // Peso aleatório entre 1 e 10\n        });\n      }\n    }\n\n    // Garantir que o grafo seja conexo (todo nó acessível)\n    for (let i = 0; i < numNodes - 1; i++) {\n      if (!edges.find((e) => e.from === i || e.to === i)) {\n        edges.push({\n          from: i,\n          to: i + 1,\n          weight: Math.floor(Math.random() * 10 + 1),\n        });\n      }\n    }\n\n    setGraph({ nodes, edges });\n    setCarPosition(null); // Resetar a posição do carrinho\n    setPath([]); // Resetar o caminho\n  };\n\n\n  const dijkstra = (nodes, edges, startNode, endNode) => {\n    const distances = {};\n    const previous = {};\n    const visited = new Set();\n\n    nodes.forEach((node) => {\n      distances[node.id] = Infinity;\n      previous[node.id] = null;\n    });\n    distances[startNode] = 0;\n\n    while (visited.size < nodes.length) {\n      const unvisitedNodes = nodes.filter((node) => !visited.has(node.id));\n      const currentNode = unvisitedNodes.reduce(\n        (a, b) => (distances[a.id] < distances[b.id] ? a : b),\n        unvisitedNodes[0]\n      );\n\n      if (distances[currentNode.id] === Infinity) break;\n\n      visited.add(currentNode.id);\n\n      edges.forEach((edge) => {\n        if (edge.from === currentNode.id || edge.to === currentNode.id) {\n          const neighborId = edge.from === currentNode.id ? edge.to : edge.from;\n          if (!visited.has(neighborId)) {\n            const newDist = distances[currentNode.id] + edge.weight;\n            if (newDist < distances[neighborId]) {\n              distances[neighborId] = newDist;\n              previous[neighborId] = currentNode.id;\n            }\n          }\n        }\n      });\n    }\n\n    const path = [];\n    let current = endNode;\n    while (current !== null) {\n      path.unshift(current);\n      current = previous[current];\n    }\n    return { path, distances };\n  };\n\n  const startSimulation = () => {\n    if (!graph) return;\n\n    const { nodes, edges } = graph;\n\n    // Calcular o menor caminho usando o algoritmo de Dijkstra\n    const result = dijkstra(nodes, edges, 0, nodes.length - 1); // Do nó 0 ao último nó\n    setPath(result.path);\n\n    // Animar o carrinho ao longo do caminho\n    let step = 0;\n    const interval = setInterval(() => {\n      if (step < result.path.length) {\n        const currentNode = nodes.find((node) => node.id === result.path[step]);\n        setCarPosition({ x: currentNode.x, y: currentNode.y });\n        step++;\n      } else {\n        clearInterval(interval); // Parar a animação ao final do caminho\n      }\n    }, 1000); // Mover o carrinho a cada 1 segundo\n  };\n\n\n  return (\n    <Container>\n      <h1>Algoritmo de Dijkstra</h1>\n      <Button onClick={generateMap}>Gerar Mapa</Button>\n      <Button onClick={startSimulation}>Iniciar</Button>\n      {graph && <Map graph={graph} carPosition={carPosition} />}\n    </Container>\n  );\n}\n\nexport default App;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}